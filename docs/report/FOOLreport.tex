\documentclass[a4paper]{article}   % list options between brackets
\usepackage[italian]{babel}              % list packages between braces
\usepackage[utf8]{inputenc}
\usepackage{listings} % needed for code styling
\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
% listings package options
% TODO change accordingly to desired style
\lstset{
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
  basicstyle=\footnotesize \color{black},        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=Java,                 % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=0,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

% type user-defined commands here

\begin{document}

\title{FCompiler: A FOOL implementation}
\author{Giulia Cantini\\
        Matteo Del Vecchio\\
        Simone Preite}
\date{20 Luglio 2018}    % type date between braces
\maketitle

\tableofcontents

\section{Introduzione}

Il progetto consiste nell'implementazione di un compilatore per un linguaggio FOOL (Functional Object Oriented Language) che traduce in bytecode
eseguibile da una stack machine SVM (Simplified Virtual Machine).\\

Di seguito si riportano le specifiche fornite per il progetto.

\subsection{Specifiche fornite}

\subsubsection{Espressioni}

Estensione delle espressioni con operatori $<=, >=, ||, \&\&, /, - $
   e not.

\subsubsection{Comandi}

Esiste la categoria sintattica \textit{stm}:\\

stm : 	id = exp (assegnamento) ; \\
	$|$ if exp then { stms } else { stms } (condizionale)\\

stms :  ( stm )+

\subsubsection{Object orientation}

È possibile dichiarare classi e sottoclassi  al top level.\\
Le classi contengono
  \begin{itemize}
    \item campi (dichiarati nella classe o ereditati dalla super-classe)
    \item metodi (esplicitamente dichiarati nella classe o ereditati dalla super-classe).
  \end{itemize}
Se in una sottoclasse viene dichiarato un metodo con il medesimo nome
di un metodo della super-classe, tale metodo sovrascrive quello della
super-classe. Non è possibile avere overriding di campi.\\
Quindi, significa che occorre estendere\\

%TODO fix indentation

\textbf{dichiarazioni}\\

   class ID [extends ID] (...campi dichiarati come parametri...) {\\

     ... metodi dichiarati come funzioni ...\\

   }

\textbf{espressioni}\\

   x.m(..)          // x e` un oggetto, m e` un metodo\\

   new C(..)				// C e` un identificatore di classe\\

   null\\

\textbf{comandi} con x.m(..), se il metodo ritorna void.

In particolare

\begin{itemize}

  \item Gli oggetti nascono come istanza di classi
  \item I campi sono modificabili
  \item Il linguaggio ha il comando di assegnamento
  \item Non è possibile dichiarare funzioni annidate. Le funzioni NON possono
    essere passate come parametri
  \item É possibile avere funzioni/metodi mutuamente ricorsive.

\end{itemize}

\subsubsection{Type check}

Il compilatore deve comprendere un type-checker che controlli il corretto uso dei tipi.
In particolare:

\begin{itemize}
  \item esiste il tipo void, oltre al tipo classe

  \item Si deve considerare una nozione di subtyping fra classi e tipi di funzioni. Il tipo
  di una funzione f1 è sottotipo del tipo di una funzione f2 se il tipo ritornato da f1
  è sottotipo del tipo ritornato da f2, se hanno il medesimo numero di parametri, e se
  ogni tipo di parametro di f1 è sopratipo del corrisponde tipo di parametro di f2.
  Una classe C1 è sottotipo di una classe C2 se C1 estende C2 e se i campi e metodi che
  vengono sovrascritti sono sottotipi rispetto ai campi e metodi corrispondenti di C2.
  Inoltre, C1 è sottotipo di C2 se esiste una classe C3 sottotipo di C2 di cui C1 è
  sottotipo.

  \item definire e implementare le regole di tipaggio per tutti i costrutti, in
  particolare per il condizionale.
\end{itemize}

\subsubsection{Il codice oggetto}

Il compilatore deve generare codice per un esecutore virtuale chiamato SVM (stack
virtual machine) la cui sintassi è definita nel file SVM.g. Tale esecutore ha una
memoria in cui gli indirizzi alti sono usati per uno stack. Uno stack pointer punta alla
locazione successiva alla prossima locazione libera per lo stack (se la memoria ha
indirizzi da 0 a MEMSIZE-1, lo stack pointer inizialmente punta a MEMSIZE).
In questo modo, quando lo stack non e` vuoto, lo stack pointer punta al top dello stack.\\

Il programma è collocato in una memoria separata puntata dall’instruction pointer
(che punta alla prossima istruzione da eseguire). Gli altri registri della macchina
virtuale sono: HP (heap pointer), RA (return address), RV (return value) e FP
(frame pointer).\\
In particolare, HP serve per puntare alla prossima locazione disponibile dello
heap; assumendo di usare gli indirizzi bassi per lo heap, HP contiene inizialmente
il valore 0.\\

\begin{itemize}
  \item Implementare tutte le operazioni per le nuove espressioni
  \item Implementare il dynamic dispatch ==> implementare e definire layout oggetti e classi
(vedi lezioni)
  \item La generazione di codice oggetto e` fatta utilizzando una grammatica con attributi,
vedere SVM.g4).
Definire una grammatica SENZA attributi (come FOOL.g4) e definire una visita
dell'albero sintattico per generare il codice.
\end{itemize}

\subsubsection{Opzionali}

La deallocazione degli oggetti nello heap (garbage collection) NON È OBBLIGATORIA.
Chi è interessato può scrivere il modulo relativo.



\section{Struttura del progetto}

Il codice sorgente del progetto è contenuto nella sottodirectory source/ che è così divisa:

\begin{itemize}
  \item \textbf{ast/} contiene i nodi dell'albero di sintassi astratta generati dal parser
  \begin{itemize}
    \item \textbf{ast/types/}
    in particolare, contiene quei nodi che rappresentano dei tipi all'interno della grammatica
  \end{itemize}
  \item \textbf{grammars/}
    contiene i file .g4 per le grammatiche FOOL e SVM con i rispettivi parser e le implementazioni dei visitor per la visita dell'ast
  \item \textbf{lib/}
    contiene la libreria (.jar) di ANTLRv4
  \item \textbf{testMain/}
    contiene le classi principali delle due rispettive configurazioni di run, Main.java per l'esecuzione standard
    e TestThread.java per l'esecuzione dei test su file .fool multipli (contenuti nella cartella FCompiler/code)
  \item \textbf{utils/}
    contiene le classi di supporto per la symbol table, il type checking e altre funzioni ausiliarie.

\end{itemize}

Il progetto è stato sviluppato usando IntelliJ IDEA, si consulti il file README.md per le istruzioni
su come aprire ed eseguire il progetto con il suddetto IDE oppure utilizzando Eclipse.

\section{Caratteristiche del linguaggio e grammatica}

Un tipico programma scritto in linguaggio FOOL è formato da un insieme di blocchi: ogni blocco può essere una dichiarazione di classe (al top level)
oppure una sequenza di dichiarazioni introdotte dalla keyword \textit{let}, seguite da un'altra sequenza di statement in cui le variabili dichiarate vengono usate, introdotta
dalla keyword \textit{in}.\\

% TODO inserisci esempio di programma, prenderlo anche dai test

\begin{lstlisting}

class A (int x = 1, int y = 2) {
  void m() print(0);
}

class
\end{lstlisting}

Le espressioni sono state estese a comprendere gli operatori $<=, >=, ||, \&\&, /, - $
   e not nella seguente maniera:\\

\begin{lstlisting}

exp   : left=operand (operator=(EQ | LEQ | GEQ ) right=exp)? ;

operand:  left=term (operator=(PLUS | MINUS) right=operand)? ;

term  : left=factor (operator=(TIMES | DIV) right=term)? ;

factor : left=atom (operator=( OR | AND) right=factor)? ;

atom : (NOT)? (MINUS)? val=value ;

value  :
        INTEGER                            #intVal
      | BOOLVAL                            #boolVal
      | NULL                               #nullVal
      | LPAR exp RPAR                      #baseExp
      | IF LPAR cond=exp RPAR THEN CLPAR thenBranch=exp CRPAR ELSE CLPAR elseBranch=exp CRPAR  #ifExp
      | var     #varExp
      | ID (LPAR (exp (COMMA exp)* )? RPAR )         #funExp
      | object=var DOT memberName=ID ( LPAR (exp (COMMA exp)* )? RPAR )?  #methodExp
      | NEW className=ID (LPAR RPAR)       #newExp
      ;

\end{lstlisting}

Sono stati aggiunti gli statement\\

\begin{lstlisting}

stm : (var | object=var DOT fieldName=ID) ASM exp #varStmAssignment
  | IF cond=exp THEN CLPAR thenBranch=stms CRPAR (ELSE CLPAR elseBranch=stms CRPAR)?  #ifStm
  | object=var DOT memberName=ID ( LPAR (exp (COMMA exp)* )? RPAR )?  #methodStm
  | PRINT LPAR exp (COMMA exp)* RPAR  #printStm
  | ID (LPAR (exp (COMMA exp)* )? RPAR )         #funStm
  ;

stms : ( stm )+  ;

\end{lstlisting}

uno statement può essere un assegnamento (semplice o a campo di un oggetto), un condizionale, una print
o una chiamata di funzione/metodo.\\
\newpage
Una dichiarazione di classe viene fatta nel modo seguente:\\

\begin{lstlisting}

class hero {
    bool iAmBatman() return true;
};

class super extends hero(int x = 0, bool cond = true) {
    int fun() return 1;
    int soMuchFun(int a, bool b) return 1000;
};
\end{lstlisting}

dove le parentesi tonde delimitano i campi e le parentesi graffe i metodi. Una classe può contenere nessun campo
ma deve contenere sempre almeno un metodo. Una classe puo` estenderne un'altra (di cui diventera' una sottoclasse)
ereditandone campi e metodi, utilizzando la keyword \textit{extends}.\\

\begin{lstlisting}
classdec : CLASS className=ID ( EXTENDS superName=ID )? (LPAR varasm (COMMA varasm)* RPAR)? CLPAR (fundec SEMIC)+ CRPAR ;

\end{lstlisting}

% TODO caratteristica da cambiare?
Un oggetto può essere istanziato utilizzando la keyword \textit{new}. Il costruttore deve essere richiamato senza argomenti, mentre i valori dei campi
sono stati già inizializzati durante la dichiarazione della classe e potranno essere modificati successivamente
tramite assegnamento.\\

%TODO completare...
Ulteriori caratteristiche del linguaggio sono le seguenti:\\
\begin{itemize}
  \item Tutte le variabili devono essere inizializzate al momento della dichiarazione (così come vale
 per i campi di una classe).
  \item Una variabile può avere tipo intero, booleano o classe (se è un oggetto).
  \item Una funzione può avere tipo di ritorno void
  \item È stato inserito il tipo null che è sottotipo di classe, per consentirne l'assegnamento ad un oggetto.
  \item Una funzione puo' opzionalmente avere un blocco let in all'interno del suo body, che e' formato da
  statement oppure statement ed eventualmente un'espressione preceduta dalla keyword \textit{return} nel caso in
  cui il suo tipo di ritorno sia diverso da void.
  %TODO completare...
\end{itemize}

\section{Analisi lessicale e sintattica (AST)}
L'interfaccia Node, implementata da tutti i nodi dell'ast e' stata modificata nel seguente modo:\\
\begin{itemize}
  \item il metodo \textbf{checkSemantics()} ha come tipo di ritorno HashSet$<$String$>$ invece di ArrayList$<$Semantic Error$>$
  questo perche` si e` eliminata la classe Semantic Error, che rappresentava solo una stringa e si e`
  optato per una gestione degli errori con HashSet per facilitare il controllo sull'inserimento
  di duplicati.
  \item il metodo \textbf{typeCheck()} adesso solleva un'eccezione quando viene rilevato un errore di tipo
  (vedi file source/utils/TypeCheckException.java).
  \item e` stato aggiunto il metodo \textbf{getID()} che restituisce l'identificatore di un oggetto sotto forma di stringa.
\end{itemize}

\subsection{Nodi degli operatori}
% TODO completare
\subsection{Nodi delle funzioni}
% TODO completare
\begin{itemize}
  \item \textbf{FunDecNode}
  \item \textbf{FunExpNode}
\end{itemize}

\subsection{Nodi per la gestione delle classi}
% TODO spiegare e eventualmente cambiare i nomi...
\begin{itemize}
  \item \textbf{BlockClassDecNode}
  \item \textbf{ClassMethodNode}
  \item \textbf{ClassFieldNode}
  \item \textbf{MethodDecNode}
  \item \textbf{ClassType}
\end{itemize}
\section{Analisi semantica}
% TODO spiegare il senso delle passate e come e quando vengono fatte

\subsection{Symbol table}

% TODO spiegare la struttura della stable e di una stentry
La tabella dei simboli viene gestita utilizzando la classe Environment (contenuta nella sottodirectory utils)
e i metodi di supporto che contiene.\\
La classe contiene i seguenti campi:\\

\begin{lstlisting}
private ArrayList<HashMap<String, SymbolTableEntry>> symTable;
private int nestingLevel;
private int offset;
private boolean secondCheck; // serve per...
private boolean secondFunCheck; // serve per...
\end{lstlisting}

In piu` contiene (oltre a getter e setter per i campi) anche i metodi:\\
% TODO scrivere come vengono dati questi id...
\begin{itemize}
  \item \textbf{public int decreaseOffset()}
  \item \textbf{public int increaseOffset()}
  \item \textbf{public SymbolTableEntry getActiveDec(String id)} scorre la symbol table
  alla ricerca della entry corrispondente alla dichiarazione al momento attiva nell'ambiente per l'oggetto rappresentato da id.
  \item \textbf{public void pushScope()} aggiunge una nuova tabella hash alla lista che rappresenta la symbol table, con nesting level incrementato.
  \item \textbf{public void popScope()} rimuove dalla symbol table la hash corrispondente al nesting level corrente, e poi lo decrementa.
  \item \textbf{public SymbolTableEntry getClassEntry(String classID)} cerca nella symbol table la entry della classe rappresentata da classID
  \item \textbf{public void updateClassEntry(ClassType type)} % TODO la usiamo per aggiornare il tipo dinamico? non la stiamo usando



\end{itemize}

% TODO metodi aggiunti, che si usano per gestire la symbol table
% TODO cose interessanti relative all'object orientation
\subsection{Type check}
% TODO spiegare quali sono i tipi base
% TODO inserire almeno l'albero del condizionale
% come si sono implementate le nozioni di sottotipaggio per funzioni/metodi e classi

\section{Generazione del codice}

\subsection{Gestione degli offset, stack, heap}
\subsection{Layout di un oggetto}
\subsection{Grammatica SVM senza attributi e SVMVisitor}
\subsection{Dynamic dispatch}
\subsection{Garbage collector (???)}

\section{Conclusioni}

%\begin{thebibliography}{9}
  % type bibliography here
%\end{thebibliography}

\end{document}
