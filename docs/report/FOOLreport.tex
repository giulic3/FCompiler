%!TEX encoding = UTF-8 Unicode
\documentclass[a4paper]{article}   % list options between brackets
\usepackage[italian]{babel}              % list packages between braces
\usepackage[utf8]{inputenc}
\usepackage{listings} % needed for code styling
\usepackage{color}
\usepackage{version}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{multirow}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\definecolor{lexerRule}{rgb}{0.47, 0.32, 0.55}
\definecolor{parserRule}{rgb}{1, 0.6, 0.2}
\definecolor{antlrlabels}{rgb}{0.45, 0.45, 0.45}

% listings package options
\lstset{
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
  basicstyle=\small \color{black} \ttfamily,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  columns=flexible,
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=Java,                 % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=0,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=4,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\lstdefinelanguage{ANTLR}
{
	keywords={SEMIC, COLON, COMMA, EQ, LEQ, GEQ, OR, AND, NOT, ASM, PLUS, MINUS, TIMES, DIV, BOOLVAL, TRUE, FALSE, LPAR, RPAR, CLPAR, CRPAR, IF, THEN, ELSE, PRINT, LET, IN, INT, BOOL, VOID, CLASS, EXTENDS, NULL, NEW, DOT, RETURN, DIGIT  , INTEGER, CHAR, ID, WS, LINECOMENTS, BLOCKCOMENTS, PUSH, POP, ADD, SUB, MULT, DIV, STOREW, LOADW, BRANCH, BRANCHEQ, BRANCHLESSEQ, JS, LOADRA, STORERA, LOADRV, STORERV, LOADFP, STOREFP, COPYFP, LOADHP, STOREHP, PRINT, HALT, NEW, CPHEAD, JSMETH, COL, LABEL, NUMBER, WHITESP, in, extends, new, return},
	morekeywords=[2]{prog, block, classdec, let, vardec, varasm, fundec, dec, type, exp, operand, term, factor, atom, value, var, stm, stms, assembly, simpleCmd, composedCmd},
	morekeywords=[3]{\#letInStms, \#classDecBlock, className, superName, \#varDecAssignment, \#funDeclaration, left, operator, right, val, \#intVal, \#boolVal, \#nullVal, \#baseExp, cond, thenBranch, elseBranch, \#ifExp, \#varExp, \#funExp, object, memberName, \#methodExp, className, \#newExp, fieldName, \#varStmAssignment, \#ifStm, \#methodStm, \#printStm, \#funStm, num, label},
	keywordstyle=\color{lexerRule},
	keywordstyle=[2]\color{parserRule},
	keywordstyle=[3]\color{antlrlabels},
	commentstyle=\color{antlrlabels},
	morecomment=[l]{\#},
	tabsize=4
}

% type user-defined commands here

\begin{document}

\title{FCompiler: A FOOL implementation}
\author{Giulia Cantini\\
        Matteo Del Vecchio\\
        Simone Preite}
\date{20 Luglio 2018}    % type date between braces
\maketitle

\tableofcontents

\section{Introduzione}

Il progetto consiste nell'implementazione di un compilatore per il linguaggio FOOL (Functional Object Oriented Language) che traduce in bytecode
eseguibile da una stack machine SVM (Simplified Virtual Machine).\\
Di seguito si riportano le specifiche fornite per il progetto.

\subsection{Specifiche fornite}

\subsubsection{Espressioni}

Estensione delle espressioni con operatori $ <=,\ >=,\ ||,\ \&\&,\ / ,\ - $ e not.

\subsubsection{Comandi}

Esiste la categoria sintattica \textit{stm}:\\
\begin{lstlisting}[language=ANTLR,basicstyle=\footnotesize\ttfamily]
stm		: id = exp (assegnamento) ;
		| if exp then { stms } else { stms } (condizionale)
stms	:  ( stm )+
\end{lstlisting}
\subsubsection{Object orientation}

E' possibile dichiarare classi e sottoclassi al top level. Esse contengono
  \begin{itemize}
    \item campi (dichiarati nella classe o ereditati dalla super-classe)
    \item metodi (esplicitamente dichiarati nella classe o ereditati dalla super-classe).
  \end{itemize}
Se in una sottoclasse viene dichiarato un metodo con il medesimo nome
di un metodo della super-classe, tale metodo sovrascrive quello della
super-classe. Non è possibile avere overriding di campi.\\
Quindi, significa che occorre estendere\\\\
\textbf{Dichiarazioni}
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
class ID [extends ID] (campi dichiarati come parametri) {
	... metodi dichiarati come funzioni ...
}
\end{lstlisting}
\textbf{Espressioni}
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
x.m(..)		// x -> oggetto, m -> metodo
new C(..)	// C -> identificatore di classe
null
\end{lstlisting}
\textbf{Comandi}
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
x.m(..)		// se il metodo ritorna void
\end{lstlisting}
In particolare
\begin{itemize}

  \item Gli oggetti nascono come istanza di classi
  \item I campi sono modificabili
  \item Il linguaggio ha il comando di assegnamento
  \item Non è possibile dichiarare funzioni annidate. Le funzioni non possono
    essere passate come parametri
  \item E' possibile avere funzioni/metodi mutuamente ricorsivi.

\end{itemize}

\subsubsection{Type check}
Il compilatore deve comprendere un type-checker che controlli il corretto uso dei tipi.
In particolare:

\begin{itemize}
  \item Esiste il tipo \lstinline|void|, oltre al tipo classe

  \item Si deve considerare una nozione di subtyping fra classi e tipi di funzioni. Il tipo
  di una funzione \lstinline|f1| è \textbf{sottotipo} del tipo di una funzione \lstinline|f2| se il tipo ritornato da \lstinline|f1|
  è sottotipo del tipo ritornato da \lstinline|f2|, se hanno il medesimo numero di parametri, e se
  ogni tipo di parametro di \lstinline|f1| è \textbf{sopratipo} del corrisponde tipo di parametro di \lstinline|f2|.\\
  Una classe \lstinline|C1| è \textbf{sottotipo} di una classe \lstinline|C2| se \lstinline|C1| estende \lstinline|C2| e se i campi e metodi che
  vengono sovrascritti sono sottotipi rispetto ai campi e metodi corrispondenti di \lstinline|C2|.
  Inoltre, \lstinline|C1| è sottotipo di \lstinline|C2| se esiste una classe \lstinline|C3| sottotipo di \lstinline|C2| di cui \lstinline|C1| è
  sottotipo.

  \item Definire e implementare le regole di tipaggio per tutti i costrutti, in
  particolare per il condizionale.
\end{itemize}

\subsubsection{Il codice oggetto}
Il compilatore deve generare codice per un esecutore virtuale chiamato SVM (stack
virtual machine) la cui sintassi è definita nel file \lstinline|SVM.g4|. Tale esecutore ha una
memoria in cui gli indirizzi alti sono usati per uno stack. Uno stack pointer punta alla
locazione successiva alla prossima locazione libera per lo stack (se la memoria ha
indirizzi da 0 a \lstinline|MEMSIZE-1|, lo stack pointer inizialmente punta a \lstinline|MEMSIZE|).
In questo modo, quando lo stack non è vuoto, lo stack pointer punta al top dello stack.\\

Il programma è collocato in una memoria separata puntata dall'instruction pointer
(che punta alla prossima istruzione da eseguire). Gli altri registri della macchina
virtuale sono: \lstinline|HP| (heap pointer), \lstinline|RA| (return address), \lstinline|RV| (return value) e \lstinline|FP| (frame pointer).\\
In particolare, \lstinline|HP| serve per puntare alla prossima locazione disponibile dello
heap; assumendo di usare gli indirizzi bassi per lo heap, HP contiene inizialmente
il valore 0.\\

\begin{itemize}
  \item Implementare tutte le operazioni per le nuove espressioni
  \item Implementare il dynamic dispatch $==>$ implementare e definire layout oggetti e classi
  \item La generazione di codice oggetto è fatta utilizzando una grammatica con attributi,
vedere \lstinline|SVM.g4|).
Definire una grammatica SENZA attributi (come \lstinline|FOOL.g4|) e definire una visita
dell'albero sintattico per generare il codice.
\end{itemize}

\subsubsection{Opzionali}
La deallocazione degli oggetti nello heap (garbage collection) non è obbligatoria.

\section{Struttura del progetto}
Il codice sorgente del progetto è contenuto nella sottodirectory \lstinline|source/| che è così divisa:

\begin{itemize}
  \item \textbf{ast/} contiene i nodi dell'albero di sintassi astratta utilizzati nell'implementazione della relativa visita
  \begin{itemize}
    \item \textbf{ast/types/}
    in particolare, contiene quei nodi che rappresentano dei tipi all'interno della grammatica
  \end{itemize}
  \item \textbf{grammars/}
    contiene i file \lstinline|.g4| per le grammatiche FOOL e SVM con i rispettivi parser e le implementazioni dei visitor per la visita dell'AST e del bytecode
  \item \textbf{lib/}
    contiene i JAR delle libreria di \lstinline|ANTLRv4|, di \lstinline|commons-cli| per eseguire il progetto da riga di comando
    e la libreria \lstinline|YAML| di supporto al testing
  \item \textbf{testMain/}
    contiene le classi principali per l'esecuzione del progetto, ovvero le
    due configurazioni di run, \lstinline|Main.java| per l'esecuzione standard con debug di un singolo programma FOOL, \lstinline|TestSuite.java| per l'esecuzione dei test contenuti nel file testSuite.yml in formato YAML e \lstinline|CommandLineMain.java| per l'esecuzione e la creazione del file JAR eseguibile da riga di comando.
  \item \textbf{utils/}
    contiene le classi di supporto per la symbol table, il type checking, eccezioni personalizzate e altre funzioni ausiliarie (come quella per ordinare gli errori semantici secondo il numero di riga e colonna).

\end{itemize}

Il progetto è stato sviluppato usando \textbf{IntelliJ IDEA}; si consulti il file \lstinline|README.md| per le istruzioni su come aprire ed eseguire il progetto con il suddetto IDE oppure utilizzando Eclipse o il terminale.

\section{Caratteristiche del linguaggio e grammatica}

Un tipico programma scritto in linguaggio FOOL è formato da un insieme di blocchi: ogni blocco può essere una dichiarazione di classe (al top level) oppure una sequenza di dichiarazioni introdotte dalla keyword \lstinline[language=ANTLR]|let|, seguite da un'altra sequenza di statement in cui le variabili dichiarate vengono usate, introdotta dalla keyword \lstinline[language=ANTLR]|in|.\\

\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
class A (int x = 1, int y = 2) {
	void m() print(0);
}
let
	A a = new A();
in
	a.m();
\end{lstlisting}
Le espressioni sono state estese per comprendere gli operatori $<=,\ >=,\ ||,\ \&\&,\ /,\ - $
   e not nella seguente maniera:\\

\begin{lstlisting}[language=ANTLR,basicstyle=\footnotesize\ttfamily]
exp		: left=operand (operator=(EQ | LEQ | GEQ) right=exp)? ;

operand	: left=term (operator=(PLUS | MINUS) right=operand)? ;

term	: left=factor (operator=(TIMES | DIV) right=term)? ;

factor	: left=atom (operator=(OR | AND) right=factor)? ;

atom	: (NOT)? (MINUS)? val=value ;

value	: INTEGER					#intVal
		| BOOLVAL					#boolVal
		| NULL						#nullVal
		| LPAR exp RPAR				#baseExp
		| var     					#varExp
		| IF LPAR cond=exp RPAR THEN CLPAR thenBranch=exp CRPAR ELSE CLPAR elseBranch=exp CRPAR  	#ifExp
		| ID (LPAR (exp (COMMA exp)* )? RPAR)	#funExp
		| object=var DOT memberName=ID (LPAR (exp (COMMA exp)* )? RPAR)?	#methodExp
		| NEW className=ID (LPAR RPAR)	#newExp
		;
\end{lstlisting}

Sono stati aggiunti gli statement\\

\begin{lstlisting}[language=ANTLR,basicstyle=\footnotesize\ttfamily]
stm	: (var | object=var DOT fieldName=ID) ASM exp	#varStmAssignment
	| IF cond=exp THEN CLPAR thenBranch=stms CRPAR (ELSE CLPAR elseBranch=stms CRPAR)?	#ifStm
	| object=var DOT memberName=ID ( LPAR (exp (COMMA exp)* )? RPAR )?	#methodStm
	| PRINT LPAR exp (COMMA exp)* RPAR	#printStm
	| ID (LPAR (exp (COMMA exp)* )? RPAR )	#funStm
	;

stms : ( stm )+  ;

\end{lstlisting}
Uno statement può essere un assegnamento (semplice o a campo di un oggetto), un condizionale, una \lstinline|print| o una chiamata di funzione/metodo.\\
\newpage
Una dichiarazione di classe viene fatta nel modo seguente:\\

\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
class hero {
    bool iAmBatman() return true;
};

class super extends hero(int x = 0, bool cond = true) {
    int fun() return 1;
    int soMuchFun(int a, bool b) return 1000;
};
\end{lstlisting}

dove le parentesi tonde delimitano i campi e le parentesi graffe i metodi. Una classe può contenere nessun campo ma deve contenere sempre almeno un metodo. Una classe può estenderne un'altra (di cui diventerà una sottoclasse), ereditandone campi e metodi, utilizzando la keyword \lstinline[language=ANTLR]|extends|.\\

\begin{lstlisting}[language=ANTLR,basicstyle=\footnotesize\ttfamily]
classdec : CLASS className=ID ( EXTENDS superName=ID )? (LPAR varasm (COMMA varasm)* RPAR)? CLPAR (fundec SEMIC)+ CRPAR ;
\end{lstlisting}

Un oggetto può essere istanziato utilizzando la keyword \lstinline[language=ANTLR]|new|. Il costruttore deve essere richiamato senza argomenti, mentre i valori dei campi sono stati già inizializzati durante la dichiarazione della classe e potranno essere modificati successivamente
tramite assegnamento.\\

Ulteriori caratteristiche del linguaggio sono le seguenti:
\begin{itemize}
  \item Tutte le variabili devono essere inizializzate al momento della dichiarazione (così come vale per i campi di una classe).
  \item Una variabile può avere tipo intero, booleano o classe (se è un oggetto).
  \item Una funzione può avere tipo di ritorno \lstinline|void|
  \item E' stato inserito il tipo \lstinline|null| che è sottotipo di classe, per consentirne l'assegnamento ad un oggetto.
  \item Una funzione può opzionalmente avere un blocco \lstinline[language=ANTLR]|let in| all'interno del suo body, che è formato da soli statement, 0 o più statement seguiti da un'espressione di ritorno oppure un'espressione preceduta dalla keyword \lstinline[language=ANTLR]|return| nel caso in cui il suo tipo di ritorno sia diverso da \lstinline|void|.
  \item La gestione degli errori sintattici nelle grammatiche non sfrutta più la regola \textit{catch-all} ERR, la quale mostrava in output nella console tali errori, bensì è stato implementato un error listener (\lstinline|LexerParserErrorListener.java|), come consigliato dalla documentazione di ANTLR v4. In caso di errore, il risultato sarà un messaggio del tipo \textit{Syntax not allowed by FOOL Language at line x:y}.
  \item Ulteriori informazioni sono presenti nei commenti della grammatica \lstinline|FOOL.g4|.
\end{itemize}

\section{Analisi lessicale e sintattica (AST)}
L'interfaccia \lstinline|Node|, implementata da tutti i nodi dell'AST è stata modificata nel seguente modo:\\
\begin{itemize}
  \item il metodo \textbf{\lstinline|checkSemantics()|} ha come tipo di ritorno \lstinline|HashSet<String>| invece di \lstinline|ArrayList<Semantic Error>|; l'oggetto di tipo \lstinline|String| rappresenta la stringa che contiene l'errore semantico e si è optato per una gestione degli errori con \lstinline|HashSet| per facilitare il controllo sull'inserimento di duplicati.
  \item il metodo \textbf{\lstinline|typeCheck()|} adesso solleva un'eccezione quando viene rilevato un errore di tipo (vedi file \lstinline|source/utils/TypeCheckException.java|).
  \item E' stato aggiunto il metodo \textbf{\lstinline|getID()|} che restituisce l'identificatore di un oggetto, o di un generico nodo, sotto forma di stringa.
\end{itemize}

\subsection{Nodi delle funzioni}
\begin{itemize}
  \item \textbf{FunDecNode} rappresenta la dichiarazione di una funzione, in esso sono memorizzati
  il nome della funzione, il suo tipo di ritorno, la lista dei parametri, la lista delle dichiarazioni e il corpo della funzione.\\
  Inoltre il nodo memorizza l'entry della symbol table associata alla funzione stessa.
  \item \textbf{FunExpNode} rappresenta l'invocazione di una funzione, in esso sono memorizzati l'ID della funzione, gli argomenti, il nesting level e una variabile di supporto \lstinline|classID| per gestire la chiamata di metodo che avviene senza dot notation (all'interno di un altro metodo). Inoltre il nodo memorizza l'entry della symbol table associata alla funzione stessa.
\end{itemize}
\subsection{Nodi per la gestione delle classi}
\begin{itemize}
  \item \textbf{BlockClassDecNode} rappresenta la dichiarazione di una classe; contiene, oltre ai metodi implementati dell'interfaccia \lstinline|Node|, le funzioni ausiliarie \lstinline|getMethods()| e \lstinline|getFields()|
  \item \textbf{ClassMethodNode} rappresenta la chiamata di metodo (\lstinline|o.m()|); è sottoclasse di FunExpNode
  \item \textbf{ClassFieldNode} rappresenta il campo di una classe
  \item \textbf{MethodDecNode} rappresenta la dichiarazione di metodo
  \item \textbf{ClassType} rappresenta il tipo classe, memorizza l'ID, l'ID dell'eventuale superclasse, la lista dei campi e dei metodi. Contiene getter e setter per gestire questi campi.
\end{itemize}

\section{Analisi semantica}
\subsection{Symbol table}

La costruzione della symbol table avviene visitando l'AST e richiamando su un ogni nodo il metodo \textbf{\lstinline|checkSemantics()|} che, a partire dal primo nodo \lstinline|ProgNode| (rappresentante la start rule della grammatica \lstinline|FOOL.g4|) viene richiamata due volte. Le due visite successive servono per la gestione delle dichiarazioni di classi e di funzioni/metodi.\\
Nel caso delle dichiarazioni di classi, la prima passata viene utilizzata per raccogliere tutte le dichiarazioni, mentre la seconda serve per gestire campi, metodi, oggetti e risolvere le relazioni di sottotipaggio tra classi.\\
Nel caso di funzioni/metodi, la doppia visita consente di implementare il meccanismo di mutua ricorsione, ovvero consente che nel corpo di una funzione possa essere chiamata un'altra funzione non ancora definita. Lo stesso vale per i metodi.\\

La tabella dei simboli viene gestita utilizzando la classe \lstinline|Environment| (contenuta nella sottodirectory \lstinline|utils|) e i metodi di supporto che essa contiene.\\
La classe contiene i seguenti campi:\\

\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
private ArrayList<HashMap<String, SymbolTableEntry>> symTable;
private int nestingLevel;
private int offset;
// questa variabile e la successiva gestiscono le passate della checkSemantics
private boolean secondCheck;
private boolean secondFunCheck;
// indica il nome della classe attualmente in definizione per aggiornare correttamente le entry della symbol table
private String definingClass = null;
\end{lstlisting}

In più contiene (oltre a getter e setter per i campi) anche i metodi:\\
% TODO scrivere come vengono dati questi id...
\begin{itemize}
  \item \textbf{\lstinline|public int decreaseOffset()|}
  \item \textbf{\lstinline|public int increaseOffset()|}
  \item \textbf{\lstinline|public SymbolTableEntry getActiveDec(String id)|}\newline Scorre la symbol table
  alla ricerca della entry corrispondente alla dichiarazione al momento attiva nell'ambiente, per l'oggetto rappresentato da ID.
  \item \textbf{\lstinline|public void pushScope()|}\newline Aggiunge una nuova tabella hash alla lista che rappresenta la symbol table, con nesting level incrementato. In altre parole ciò avviene quando si entra in un nuovo scope.
  \item \textbf{\lstinline|public void popScope()|}\newline Rimuove dalla symbol table la hash corrispondente al nesting level corrente, e poi lo decrementa.
  \item \textbf{\lstinline|public SymbolTableEntry getClassEntry(String classID)|}\newline Cerca nella symbol table la entry della classe rappresentata da \lstinline|classID|
  %\item \textbf{public void updateClassEntry(ClassType type)} % la usiamo per aggiornare il tipo dinamico? non la stiamo usando

\end{itemize}

La tabella dei simboli viene riempita utilizzando la classe \lstinline|SymbolTableEntry| che possiede i seguenti campi:
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
private int nestingLevel;
private int offset;
private Node type;  // nel caso degli oggetti, indica il tipo dinamico
private String className; // usata nel caso di entry che rappresentano classi
private Node staticType; // usata nel caso di classi
\end{lstlisting}

\subsection{Type check}
I tipi su cui si basa il sistema di tipaggio di FOOL sono i seguenti:

\begin{itemize}
  \item \lstinline|BoolType|
  \item \lstinline|ClassType|
  \item \lstinline|FunType|
  \item \lstinline|IntType|
  \item \lstinline|NullType|
  \item \lstinline|VoidType|
\end{itemize}

Il sottotipaggio viene controllato utilizzando la funzione
\begin{itemize}
\item \lstinline|public static boolean subtypeOf(Node a, Node b)|
\end{itemize}
che restituisce \lstinline|true| se il nodo \lstinline|a| è sottotipo del nodo \lstinline|b| (in \lstinline|Helpers|).
In particolare, \lstinline|bool| è sottotipo di \lstinline|int|, \lstinline|void| è sottotipo di classe, mentre una classe è sottoclasse di un'altra se intersecando la lista delle superclassi della prima con la lista delle superclassi della seconda si ottiene un insieme non vuoto.\\
Il sottotipaggio tra funzioni/metodi viene gestito all'interno delle \lstinline|typeCheck()| di \lstinline|FunDecNode| e \lstinline|MethodDecNode|: come da specifica, il controllo viene eseguito
su tipo di ritorno e tipi e numero dei parametri per verificare che i tipi delle funzioni siano compatibili.\\
\newline
Si sono implementate le regole di tipaggio per tutti i costrutti:
% riporto solo quelle effettivamente necessarie a fare type inference ( i costrutti che danno void non contribuiscono al tipo dell'albero)

\begin{itemize}
  \item Costanti intere
  $$ \frac{\text{x \ \ is \ \ an} \ \ int \ \ \text{token}}{\vdash x : int}[IntVal] $$
  
  \item Costanti booleane
  $$ \frac{}{\vdash true : bool}[BoolVal_1] \qquad \frac{}{\vdash false : bool}[BoolVal_2] $$
  
  \item Operatori logici e relazionali
  % not
  $$ \frac{\Gamma\vdash e : bool}{\vdash\ not\ e : bool}[Not] $$\\
  % and, or
  $$ \frac{\Gamma \vdash e_1 : bool \qquad \Gamma \vdash e_2 : bool}{\Gamma \vdash e_1 \ \&\& \ e_2 : bool}[And] \qquad \frac{\Gamma \vdash e_1 : bool \qquad \Gamma \vdash e_2 : bool}{\Gamma \vdash e_1 \ || \ e_2 : bool}[Or] $$\\
  % equal
  $$ \frac{\Gamma \vdash e_1 : T_1 \qquad \Gamma \vdash e_2 : T_2 \qquad T_1 <: T \qquad T_2<:T}{\Gamma \vdash e_1 \ == \ e_2 : bool}[Equal] $$\\
  % lessequal, greaterequal
  $$ \frac{\Gamma \vdash e_1 : int \qquad \Gamma \vdash e_2 : int}{\Gamma \vdash e_1 \ <= \ e_2 : bool}[LessEqual] \qquad \frac{\Gamma \vdash e_1 : int \qquad \Gamma \vdash e_2 : int}{\Gamma \vdash e_1 \ >= \ e_2 : bool}[GreaterEqual] $$\\

  \item Operatori aritmetici
  % plus, sub
  $$ \frac{\Gamma \vdash e_1 : int \qquad \Gamma \vdash e_2 : int}{\Gamma \vdash e_1 \ + \ e_2 : int}[Plus] \qquad \frac{\Gamma \vdash e_1 : int \qquad \Gamma \vdash e_2 : int}{\Gamma \vdash e_1 \ - \ e_2 : int}[Sub] $$\\
  % times, div
  $$ \frac{\Gamma \vdash e_1 : int \qquad \Gamma \vdash e_2 : int}{\Gamma \vdash e_1 \ \times \ e_2 : int}[Times] \qquad \frac{\Gamma \vdash e_1 : int \qquad \Gamma \vdash e_2 : int}{\Gamma \vdash e_1 \ / \ e_2 : int}[Div] $$\\
  % unary minus
  $$ \frac{\Gamma \vdash e_1 : int}{\Gamma \vdash (- e_1) : int}[UnaryMinus] $$\\
  
  \item Costrutto condizionale (con subtyping)
  % ifexp1
  $$ \frac{\Gamma \vdash c : bool \qquad \Gamma \vdash e_1 : T_1 \qquad \Gamma \vdash e_2 : T_2 \qquad T_2 <: T_1}{\Gamma \vdash if \ \ (c) \ \ then \ \ {e_1} \ \ else \ \ {e_2} : T1}[IfExp_1] $$\\
  % ifexp2
  $$ \frac{\Gamma \vdash c : bool \qquad \Gamma \vdash e_1 : T_1 \qquad \Gamma \vdash e_2 : T_2 \qquad T_1 <: T_2}{\Gamma \vdash if \ \ (c) \ \ then \ \ {e_1} \ \ else \ \ {e_2} : T2}[IfExp_2] $$\\
  % ifstm
  $$ \frac{\Gamma \vdash c : bool \qquad \Gamma \vdash s_1 : T_1 \qquad \Gamma \vdash s_2 : T_2 \qquad T_1 <: void \qquad T_2 <: void}{\Gamma \vdash if \ \ (c) \ \ then \ \ {s_1} \ \ else \ \ {s_2} : void}[IfStm] $$\\

  \item Variabili
  $$ \frac{\Gamma(x) = T}{\Gamma \vdash x : T}[Var]$$

  \item Print
  $$ \frac{(\Gamma \vdash e_i : T_i \qquad T_i\ != void)^{i\ \in\ 1, ...,n}}{\Gamma \vdash print(e_1,...,e_n) : void }[Print]$$
  
  \item Definizione di funzione (ricorsiva e non)
  $$ \frac{\Gamma [p_1 \rightarrow T_1, \ ..., \ p_n \rightarrow T_n] \vdash e : T}{\Gamma \vdash T \ f(T_1 \ p_1, ..., T_n \ p_n) \ e;\ \ : \ (T_1, ..., T_n) \rightarrow T}[FunDec]$$
  $$\frac{\Gamma [f \rightarrow (T_1, ..., T_n) \rightarrow T,\ p_1 \rightarrow T_1, \ ..., \ p_n \rightarrow T_n] \vdash e : T}{\Gamma \vdash T \ f(T_1 \ p_1, ..., T_n \ p_n) \ e;\ \ : \ (T_1, ..., T_n) \rightarrow T}[RecFunDec]$$\\

  \item Chiamata di funzione (con subtyping)
  $$ \frac{\Gamma \vdash f : (T_1, ..., T_n) \rightarrow T \qquad (\Gamma \vdash e_i : T_i' \  \ \ \ T_i' <: T_i )^{i\ \in\ 1, ...,n}}{\Gamma \vdash f(e_1,...,e_n) : T}[SbtFunCall] $$

  \item Chiamata di metodo (con subtyping)
  $$ \frac{\Gamma(o) = C \qquad \Gamma(C)(m) = T_1, ... , T_n \rightarrow T \qquad (\Gamma \vdash e_i : T_i' \ \ \ T_i' <: T_i)^{i\ \in\ 1, ...,n}}{\Gamma \vdash o.m(e_1,...,e_n) : T}[SbtMethodCall] $$
  
  \item Method overriding\\
  Si assume che:
  \begin{itemize}
  	\item il tipo del metodo nella classe A sia $(T_1,\ ...,\ T_n) \rightarrow T$
	\item il tipo del metodo nella classe B sia $(T_1',\ ...,\ T_n') \rightarrow T'$
	\item A sia superclasse per B: $B <: A$\\
  \end{itemize}
  $$ \frac{(T_i <: T_i')^{i\ \in\ 1,...,n} \qquad T' <: T}{(T_1',\ ...,\ T_n') \rightarrow T' \quad <: \quad (T_1,\ ...,\ T_n) \rightarrow T}[MtdOverride] $$\\

  \item Accesso ad un campo
  $$ \frac{\Gamma(o) = C \qquad \Gamma(C)(x) = T}{\Gamma \vdash o.x : T}[Field] $$

  \item Istanziazione di un oggetto (new)
  $$ \frac{\Gamma \vdash new \ C : () \rightarrow C}{\Gamma \vdash new \ C() : C}[New] $$

  \item Assegnamento (con subtyping)
  $$ \frac{\Gamma(x) = T_1 \qquad \Gamma \vdash e : T_2 \qquad T_2 <: T_1}{\Gamma \vdash x = e : void}[Assignment] $$

  \item Comandi
  $$ \frac{\Gamma \vdash stm : void \qquad \Gamma \vdash stms : void}{\Gamma \vdash stm ; stms : void}[SeqStms] $$
\end{itemize}
\section{Generazione del codice}

\subsection{Gestione degli offset, stack, heap}
All'interno della SVM utilizzata, la memoria viene rappresentata come un Array di interi ed al suo interno salvate le informazioni utili all'esecuzione di un programma scritto in \lstinline|FOOL|.\\
Lo Stack della memoria è il luogo in cui sono conservate, finchè necessario, le informazioni relative al calcolo in esecuzione. Questa parte di memoria per convenzione cresce verso il basso
pertanto il suo indirizzo di partenza sarà l'ultimo della memoria (il più grande).\\
Lo Heap invece viene usato per lo storage delle informazioni degli oggetti istanziati e cresce verso l'alto pertanto il suo indirizzo di partenza sarà zero.\\
L'Array di interi utilizzato per Stack e Heap, com'è facilmente intuibile, è lo stesso:
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
public static final int MEMSIZE = 10000;
private int[] memory = new int[MEMSIZE];
\end{lstlisting}
\begin{tabular}{ l | l | l | l | l | l | l | l | l | l | l | l | l | l | l     }
    \hline
    STACK & 12 & 11 & 10 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & HEAP\\ \hline
    $\dashrightarrow$ &  &  &  &  &  &  &  &  &  &  &  &  & &  $\dashleftarrow$\\ \hline
  \end{tabular}
\\\\\\
I riferimenti agli oggetti istanziati nello heap sono contenuti nello Stack sotto forma di indirizzo, quando ad un certo punto del nostro codice verrà eseguita l'istruzione \lstinline|NEW| verrà allocato nello heap uno spazio di memoria sufficiente a contenere l'oggetto che si sta creando e come valore di ritorno verrà restituito l'indirizzo di inizio di questa area di memoria.
\\\\
La gestione degli offest è molto semplice. Ogni volta che viene dichiarata una nuova variabile l'offset di questa verrà decrementato perchè essendo rappresentata sullo Stack abbiamo gli indirizzi crescenti verso il basso, mentre se si tratta della dichiarazione del campo di una classe l'offest verrà incrementato perchè i campi vengono istanziati sullo Heap che ha gli indirizzi crescenti verso l'alto.

\subsubsection{Implementazione del \lstinline|null|}
Per poter gestire in modo appropriato gli oggetti nulli, bisognava scegliere il modo in cui implementarli per la macchina virtuale. La scelta era ovviamente ristretta all'uso di numeri interi ma è stata subito esclusa la possibilità di utilizzare lo zero, in quanto ritenuto un valore troppo significativo (soprattutto relativamente agli offset e agli indirizzi).\\
La scelta è quindi ricaduta sul valore intero massimo rappresentabile in Java (\lstinline|Integer.MAX_VALUE|, ovvero 2147483647). Considerando che la macchina virtuale ha una memoria massima di 10000, non è possibile che esista un indirizzo avente tale valore; inoltre, si è aggiunto un controllo semantico che impedisce l'uso di tale valore come un semplice numero intero. Di conseguenza, incontrare il valore 2147483647 nell'assembly potrà essere solamente attribuito ad un oggetto nullo.\\
Nel momento in cui si cerca di caricare o accedere ad un campo/metodo di un oggetto nullo (tramite una \lstinline[language=ANTLR]|ADD| o una \lstinline[language=ANTLR]|LOADW|), la macchina virtuale solleva un'eccezione \lstinline|NullObjectException|, implementata appositamente per tale scopo.
\subsection{Layout di un oggetto}
Gli oggetti, come già anticipato, vengono istanziati sulla parte di memoria che rappresenta lo HEAP pertanto la loro dimensione cresce verso l'alto.\\
La struttura si compone di due aree:
\begin{itemize}
\item \textbf{Dispatch Table}\newline
Nella Dispatch Table sono salvati i riferimenti a tutte le implementazioni dei metodi della classe, di quelli ereditati e di quelli eventualmente sovrascritti.\\
La DT si trova ad offset zero rispetto all'inizio in memoria dell'area di memoria dedicata all'oggetto.
\item \textbf{Campi}\newline
I campi sono tutte le variabili e gli oggetti caratteristici che compongono il tipo classe dell'oggetto e quindi, anche in questo caso, è riservato dello spazio in memoria per quelli della classe in questione ed eventuali campi ereditati; non essendo possibile avere overriding di campi da specifica, non è stato necessario gestire questa eventualità.
Per ogni campo viene riservato lo spazio necessario a contenere il valore o l'indirizzo di riferimento nel caso in cui il campo in questione sia istanza a sua volta di un oggetto.
Come esempio prendiamo la dichiarazione di una classe e l'istanza di un oggetto di questa classe:
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
class A (int k = 2){
	void m() print(k);
}
class ciao (int x = true, bool z = 9, A a = new A()){
    bool f(int g, int h) let int x=1; in x=1;
    void z() return 0;
};
let
    ciao x = new ciao();
in
    x.z();
\end{lstlisting}
Il risultato sullo heap sarà circa il seguente:
\end{itemize}
\begin{center}
\begin{tabular}{|c|c|l|cl}
\multicolumn{3}{|c|}{\vdots}      &  & \multicolumn{1}{c}{}            \\ \cline{1-3} \cline{5-5} 
5 & 0  & a object address in Heap &  & \multirow{4}{*}{Oggetto x}      \\ \cline{1-3}
4 & 9  & Integer field            &  &                                 \\ \cline{1-3}
3 & 1  & Boolean field            &  &                                 \\ \cline{1-3}
2 & 62 & Dispatch Table ciao      &  &                                 \\ \cline{1-3} \cline{5-5} 
1 & 2  & Integer field            &  & \multirow{2}{*}{Oggetto a di x} \\ \cline{1-3}
0 & 56 & Dispatch Table A         &  &                                 \\ \cline{1-3} \cline{5-5} 
\end{tabular}
\end{center}
Gli indirizzi delle due Dispatch Table per \lstinline|A| e \lstinline|ciao| sono fittizi.
\subsection{Grammatica SVM senza attributi e SVMVisitor}
Il progetto di base forniva una grammatica, \lstinline|SVM.g4|, già implementata per la generazione del codice oggetto. Essa però conteneva attributi, ovvero particolare azioni in Java da effettuare nel momento in cui un determinato token sarebbe stato matchato con l'input.\\
Come richiesto dalle specifiche del progetto, è stata implementata una visita per la generazione del codice, trasformando la grammatica fornita in una senza attributi. Sebbene quella iniziale fosse semplice, è stato ritenuto opportuno modificarla in modo radicale per favorire una migliore gestione della visita sull'AST generato.\\
Il risultato è il seguente:
\begin{lstlisting}[language=ANTLR,basicstyle=\footnotesize\ttfamily]
assembly: ( simpleCmd )* ;

simpleCmd: ( composedCmd | POP | ADD | SUB | MULT | DIV | STOREW
			| LOADW | JS | LOADRA | STORERA | LOADRV | STORERV
			| LOADFP | STOREFP | COPYFP | LOADHP | STOREHP | PRINT
			| HALT | NEW | LABEL | CPHEAD | JSMETH ) ;

composedCmd: ( PUSH num=NUMBER | PUSH label=LABEL | label=LABEL COL
            | BRANCH label=LABEL | BRANCHEQ label=LABEL
            | BRANCHLESSEQ label=LABEL ) ;
\end{lstlisting}
Rispetto alla grammatica di partenza, sono state introdotte le seguenti istruzioni assembly che hanno quindi richiesto la modifica del file \lstinline|ExecuteVM.java|:
\begin{itemize}
\item NEW\newline
Si occupa dell'istanziazione di un oggetto nell'heap. L'istruzione assume di avere sulla testa dello stack l'indirizzo della Dispatch Table relativa al tipo dell'oggetto in questione, il numero di campi ed i relativi valori. Il risultato consiste nella creazione dell'oggetto nell'heap e nella restituzione, sulla testa dello stack, dell'indirizzo di tale oggetto.
\item CPHEAD\newline
Semplice istruzione che si occupa di duplicare il valore presente sulla testa dello stack. Viene utilizzato durante la code generation dei metodi di un oggetto.
\item JSMETH\newline
Pusha sullo stack l'indirizzo della prima istruzione del metodo invocato, in modo da usare successivamente l'istruzione \lstinline|JS| per l'esecuzione dello stesso.\\\\
\end{itemize}
Inoltre, sono stati aggiunti i seguenti campi al Parser SVM:
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
public static int[] code = new int[ExecuteVM.CODESIZE];
static int i = 0;
static HashMap<String,Integer> labelAdd = new HashMap<String,Integer>();
static HashMap<Integer,String> labelRef = new HashMap<Integer,String>();
static void resetSVM() {
    code = new int[ExecuteVM.CODESIZE];
    i = 0;
    labelAdd = new HashMap<String,Integer>();
    labelRef = new HashMap<Integer,String>();
}
\end{lstlisting}
L'implementazione della visita è presente nel file \lstinline|SVMVisitorImpl.java| e, per poter accedere alle suddette variabili del parser, sono state dichiarate in modo statico. Per questo motivo però, è stato necessario creare il metodo \lstinline|resetSVM()|, in modo da azzerare il contenuto della macchina virtuale ogni qual volta venga eseguito un programma (come ad esempio nel caso dei test, i quali sono valutati automaticamente uno dopo l'altro).\\\\
L'idea alla base della nostra implementazione della visita è costituita dall'uso di tre regole per il parser e dei relativi metodi di visita:
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
public Void visitAssembly(AssemblyContext ctx);
public Void visitSimpleCmd(SimpleCmdContext ctx);
public Void visitComposedCmd(ComposedCmdContext ctx);
\end{lstlisting}
\lstinline|visitAssembly()| rappresenta il punto d'inizio della visita dell'intero AST, gestisce il reset della macchina virtuale e la trasformazione delle label in opportuni interi; inoltre, utilizzando questo approccio, ci è stato facile ricavare il numero totale di nodi su cui ciclare per riempire l'array contenente il codice.\\
\lstinline|visitSimpleCmd()| gestisce tutte le istruzioni assembly semplici, che non hanno parametri, in quanto la loro semantica consiste solo nell'aggiunta dell'opportuno codice istruzione nell'array \lstinline|code|.\\
Infine, \lstinline|visitComposedCmd()| gestisce le istruzioni assembly che necessitano di più operazioni oltre alla semplice memorizzazione del codice istruzione; in particolare, si tratta di operazioni relative alla creazione/associazione delle label nel codice.\\
La visita e la generazione del codice da far eseguire alla macchina virtuale avviene con il seguente codice:
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
// si assume che input sia un CharStream contenente il testo da parsare
SVMLexer asmLexer = new SVMLexer(input);
CommonTokenStream asmTokens = new CommonTokenStream(asmLexer);
SVMParser asmParser = new SVMParser(asmTokens);
SVMVisitorImpl asmVisitor = new SVMVisitorImpl();

asmVisitor.visit(asmParser.assembly());
\end{lstlisting}
Per migliorare il risultato dell'esecuzione della macchina virtuale, il file \lstinline|ExecuteVM.java| è stato ulteriormente modificato in modo da individuare la divisione per zero e l'accesso ad un oggetto nullo (tramite le eccezioni custom \lstinline|DivisionByZeroException| e \lstinline|NullObjectException|).\\
Attraverso due \lstinline|ArrayList| di stringhe, \lstinline|outputBuffer| e \lstinline|errorBuffer|, la macchina virtuale restituisce il proprio output, come mostrato nel codice seguente (continuazione di quello precedente):
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
ExecuteVM vm = new ExecuteVM(SVMParser.code);
vm.cpu();

if (!vm.errorBuffer.isEmpty()) {
	if (verbose) result.append("Some errors occurred during execution:\n");
	for (String e: vm.errorBuffer)
		result.append(e).append("\n");
}
else {
	if (verbose) result.append("Virtual Machine execution result:\n");
	if (vm.outputBuffer.size() == 0)
		result.append("Execution completed. No output shown.\n");
	else
		for (String res: vm.outputBuffer)
			result.append(res).append("\n");
}
\end{lstlisting}
\subsection{Dynamic dispatch}
Le dispatch table per le classi sono gestite attraverso la creazione di una HashMap e una ArrayList di metodi per ogni entry, dove come chiave viene utilizzata una concatenazione tra il nome della classe e la stringa "DTClass".
\\
La label del metodo viene inserita alla posizione dell'ArrayList corrispondente all'offset nella codegeneration.
\\
Se un metodo viene sovrascritto da uno nuovo, questo prenderà l'offset del metodo originario e verrà modificata soltanto la Label corrispondente all'interno della Dispatch Table.
\section{Testing}
Il testing dell'intero progetto è avvenuto secondo due modalità diverse: la scrittura di file .fool contemporaneamente allo sviluppo progressivo del progetto (i file sono presenti nella directory \lstinline|code/|) e l'implementazione di una suite di test YAML a conclusione del progetto.\\
Quest'ultima modalità è totalmente automatica e si basa sulla scrittura di test secondo la seguente sintassi:
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
testNUM - Nome test:
- codice FOOL da eseguire
- "risultato atteso"
\end{lstlisting}
La scrittura di un test personalizzato consiste quindi nello scegliere un nome ed un numero identificato per il test, nello scrivere il codice da testare e nell'indicare la stringa rappresentante il valore, o l'errore, atteso.\\
E' fondamentale seguire la sintassi al fine di evitare errori di parsing.\\
Tali test vanno quindi scritti nel file \lstinline|testSuite.yml| oppure in un nuovo file, da poter poi testare con \lstinline|FCompiler.jar|, seguendo le istruzioni fornite nel file \lstinline|README.md|.
\section{Conclusioni}
In conclusione, sono state soddisfatte tutte le richieste fondamentali delle specifiche, dando particolare attenzione alla gestione delle situazioni d'errore, al testing e all'implementazione del Visitor per la grammatica \lstinline|SVM.g4|.\\
Inoltre, nel file \lstinline|testSuite.yml| sono presenti 56 piccoli test, ognuno dei quali si occupa di mostrare una particolare caratteristica del linguaggio FOOL da noi realizzato.

%\begin{thebibliography}{9}
  % type bibliography here
%\end{thebibliography}

\end{document}
