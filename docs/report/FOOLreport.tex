\documentclass[a4paper]{article}   % list options between brackets
\usepackage[italian]{babel}              % list packages between braces
\usepackage{blindtext} % used for title and subtitle format
\usepackage[utf8]{inputenc}
% type user-defined commands here

\begin{document}

\title{FCompiler: A FOOL implementation\\
Progetto di Compilatori e Interpreti,\\
          anno accademico 2017/2018}   % type title between braces
\author{Giulia Cantini (giulia.cantini2@studio.unibo.it)\\
        Matteo Del Vecchio (matteo.delvecchio6@studio.unibo.it)\\
        Simone Preite (simone.preite@studio.unibo.it)}
\date{20 Luglio 2018}    % type date between braces
\maketitle

\tableofcontents

\section{Introduzione}

Il progetto consiste nell'implementazione di un compilatore per un linguaggio FOOL (Functional Object Oriented Language) che traduce in bytecode
eseguibile da una stack machine SVM (Simplified Virtual Machine).

Di seguito si riportano le specifiche fornite per il progetto.

\subsection{Specifiche fornite}

\subsubsection{Espressioni}

Estensione delle espressioni con operatori $<=, >=, ||, \&\&, /, - $
   e not.

\subsubsection{Comandi}

Esiste la categoria sintattica \textit{stm}:\\

stm : 	id = exp (assegnamento) ; \\
	$|$ if exp then { stms } else { stms } (condizionale)\\

stms :  ( stm )+

\subsubsection{Object orientation}

È possibile dichiarare classi e sottoclassi  al top level.\\
Le classi contengono
  \begin{itemize}
    \item campi (dichiarati nella classe o ereditati dalla super-classe)
    \item metodi (esplicitamente dichiarati nella classe o ereditati dalla super-classe).
  \end{itemize}
Se in una sottoclasse viene dichiarato un metodo con il medesimo nome
di un metodo della super-classe, tale metodo sovrascrive quello della
super-classe. Non è possibile avere overriding di campi.\\
Quindi, significa che occorre estendere\\

%TODO fix indentation

\textbf{dichiarazioni}\\

   class ID [extends ID] (...campi dichiarati come parametri...) {\\

     ... metodi dichiarati come funzioni ...\\

   }

\textbf{espressioni}\\

   x.m(..)          // x e` un oggetto, m e` un metodo\\

   new C(..)				// C e` un identificatore di classe\\

   null\\

\textbf{comandi} con x.m(..), se il metodo ritorna void.

In particolare

\begin{itemize}

  \item Gli oggetti nascono come istanza di classi
  \item I campi sono modificabili
  \item Il linguaggio ha il comando di assegnamento
  \item Non è possibile dichiarare funzioni annidate. Le funzioni NON possono
    essere passate come parametri
  \item É possibile avere funzioni/metodi mutuamente ricorsive.

\end{itemize}

\subsubsection{Type check}

Il compilatore deve comprendere un type-checker che controlli il corretto uso dei tipi.
In particolare:

\begin{itemize}
  \item esiste il tipo void, oltre al tipo classe

  \item Si deve considerare una nozione di subtyping fra classi e tipi di funzioni. Il tipo
  di una funzione f1 è sottotipo del tipo di una funzione f2 se il tipo ritornato da f1
  è sottotipo del tipo ritornato da f2, se hanno il medesimo numero di parametri, e se
  ogni tipo di parametro di f1 è sopratipo del corrisponde tipo di parametro di f2.
  Una classe C1 è sottotipo di una classe C2 se C1 estende C2 e se i campi e metodi che
  vengono sovrascritti sono sottotipi rispetto ai campi e metodi corrispondenti di C2.
  Inoltre, C1 è sottotipo di C2 se esiste una classe C3 sottotipo di C2 di cui C1 è
  sottotipo.

  \item definire e implementare le regole di tipaggio per tutti i costrutti, in
  particolare per il condizionale.
\end{itemize}

\subsubsection{Il codice oggetto}

Il compilatore deve generare codice per un esecutore virtuale chiamato SVM (stack
virtual machine) la cui sintassi è definita nel file SVM.g. Tale esecutore ha una
memoria in cui gli indirizzi alti sono usati per uno stack. Uno stack pointer punta alla
locazione successiva alla prossima locazione libera per lo stack (se la memoria ha
indirizzi da 0 a MEMSIZE-1, lo stack pointer inizialmente punta a MEMSIZE).
In questo modo, quando lo stack non e` vuoto, lo stack pointer punta al top dello stack.\\

Il programma è collocato in una memoria separata puntata dall’instruction pointer
(che punta alla prossima istruzione da eseguire). Gli altri registri della macchina
virtuale sono: HP (heap pointer), RA (return address), RV (return value) e FP
(frame pointer).\\
In particolare, HP serve per puntare alla prossima locazione disponibile dello
heap; assumendo di usare gli indirizzi bassi per lo heap, HP contiene inizialmente
il valore 0.\\

\begin{itemize}
  \item Implementare tutte le operazioni per le nuove espressioni
  \item Implementare il dynamic dispatch ==> implementare e definire layout oggetti e classi
(vedi lezioni)
  \item La generazione di codice oggetto e` fatta utilizzando una grammatica con attributi,
vedere SVM.g4).
Definire una grammatica SENZA attributi (come FOOL.g4) e definire una visita
dell'albero sintattico per generare il codice.
\end{itemize}

\subsubsection{Opzionali}

La deallocazione degli oggetti nello heap (garbage collection) NON È OBBLIGATORIA.
Chi è interessato può scrivere il modulo relativo.



\section{Struttura del progetto}

Il codice sorgente del progetto è contenuto nella sottodirectory source/ che è così divisa:

\begin{itemize}
  \item \textbf{ast/} contiene i nodi dell'albero di sintassi astratta generati dal parser
  \begin{itemize}
    \item \textbf{ast/types/}
    in particolare, contiene quei nodi che rappresentano dei tipi all'interno della grammatica
  \end{itemize}
  \item \textbf{grammars/}
    contiene i file .g4 per le grammatiche FOOL e SVM
  \item \textbf{lib/}
    contiene la libreria (.jar) di ANTLRv4
  \item \textbf{testMain/}
    contiene le classi principali delle due rispettive configurazioni di run, Main.java per l'esecuzione "normale"
    e TestThread.java per l'esecuzione dei test su file .fool multipli (contenuti nella cartella FCompiler/code)
  \item \textbf{utils/}
    contiene le classi di supporto per la symbol table, il typecheck e altre funzioni ausiliarie.

\end{itemize}

Il progetto è stato sviluppato usando IntelliJ IDEA, consultare il file README.md per le istruzioni
su come aprire ed eseguire il progetto con il suddetto IDE o utilizzando Eclipse.

\section{Specifiche del linguaggio e grammatica}


\section{Ast}

\section{Analisi semantica}

\subsection{Symbol Table}
\subsection{Type check}

\section{Generazione del codice}

\subsection{Gestione degli offset, stack, heap}
\subsection{Grammatica SVM senza attributi e SVMVisitor}
\subsection{Dynamic dispatch}
\subsection{Garbage collector (???)}

\section{Conclusioni}

\begin{thebibliography}{9}
  % type bibliography here
\end{thebibliography}

\end{document}
