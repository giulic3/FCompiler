\documentclass[a4paper]{article}   % list options between brackets
\usepackage[italian]{babel}              % list packages between braces
\usepackage[utf8]{inputenc}
\usepackage{listings} % needed for code styling
\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
% listings package options
% TODO change accordingly to desired style
\lstset{
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
  basicstyle=\footnotesize \color{black},        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=Java,                 % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=0,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

% type user-defined commands here

\begin{document}

\title{FCompiler: A FOOL implementation}
\author{Giulia Cantini\\
        Matteo Del Vecchio\\
        Simone Preite}
\date{20 Luglio 2018}    % type date between braces
\maketitle

\tableofcontents

\section{Introduzione}

Il progetto consiste nell'implementazione di un compilatore per il linguaggio FOOL (Functional Object Oriented Language) che traduce in bytecode
eseguibile da una stack machine SVM (Simplified Virtual Machine).\\

Di seguito si riportano le specifiche fornite per il progetto.

\subsection{Specifiche fornite}

\subsubsection{Espressioni}

Estensione delle espressioni con operatori $ <=,  >=, || , \&\&, / ,  - $
   e not.

\subsubsection{Comandi}

Esiste la categoria sintattica \textit{stm}:\\

stm : 	id = exp (assegnamento) ; \\
	$|$ if exp then { stms } else { stms } (condizionale)\\

stms :  ( stm )+

\subsubsection{Object orientation}

È possibile dichiarare classi e sottoclassi  al top level.\\
Le classi contengono
  \begin{itemize}
    \item campi (dichiarati nella classe o ereditati dalla super-classe)
    \item metodi (esplicitamente dichiarati nella classe o ereditati dalla super-classe).
  \end{itemize}
Se in una sottoclasse viene dichiarato un metodo con il medesimo nome
di un metodo della super-classe, tale metodo sovrascrive quello della
super-classe. Non è possibile avere overriding di campi.\\
Quindi, significa che occorre estendere\\

%TODO fix indentation

\textbf{dichiarazioni}\\

   class ID [extends ID] (...campi dichiarati come parametri...) {\\

     ... metodi dichiarati come funzioni ...\\

   }

\textbf{espressioni}\\

   x.m(..)          // x e` un oggetto, m e` un metodo\\

   new C(..)				// C e` un identificatore di classe\\

   null\\

\textbf{comandi} con x.m(..), se il metodo ritorna void.

In particolare

\begin{itemize}

  \item Gli oggetti nascono come istanza di classi
  \item I campi sono modificabili
  \item Il linguaggio ha il comando di assegnamento
  \item Non è possibile dichiarare funzioni annidate. Le funzioni non possono
    essere passate come parametri
  \item È possibile avere funzioni/metodi mutuamente ricorsivi.

\end{itemize}

\subsubsection{Type check}

Il compilatore deve comprendere un type-checker che controlli il corretto uso dei tipi.
In particolare:

\begin{itemize}
  \item Esiste il tipo void, oltre al tipo classe

  \item Si deve considerare una nozione di subtyping fra classi e tipi di funzioni. Il tipo
  di una funzione f1 è sottotipo del tipo di una funzione f2 se il tipo ritornato da f1
  è sottotipo del tipo ritornato da f2, se hanno il medesimo numero di parametri, e se
  ogni tipo di parametro di f1 è sopratipo del corrisponde tipo di parametro di f2.\\
  Una classe C1 è sottotipo di una classe C2 se C1 estende C2 e se i campi e metodi che
  vengono sovrascritti sono sottotipi rispetto ai campi e metodi corrispondenti di C2.
  Inoltre, C1 è sottotipo di C2 se esiste una classe C3 sottotipo di C2 di cui C1 è
  sottotipo.

  \item Definire e implementare le regole di tipaggio per tutti i costrutti, in
  particolare per il condizionale.
\end{itemize}

\subsubsection{Il codice oggetto}

Il compilatore deve generare codice per un esecutore virtuale chiamato SVM (stack
virtual machine) la cui sintassi è definita nel file SVM.g. Tale esecutore ha una
memoria in cui gli indirizzi alti sono usati per uno stack. Uno stack pointer punta alla
locazione successiva alla prossima locazione libera per lo stack (se la memoria ha
indirizzi da 0 a MEMSIZE-1, lo stack pointer inizialmente punta a MEMSIZE).
In questo modo, quando lo stack non è vuoto, lo stack pointer punta al top dello stack.\\

Il programma è collocato in una memoria separata puntata dall’instruction pointer
(che punta alla prossima istruzione da eseguire). Gli altri registri della macchina
virtuale sono: HP (heap pointer), RA (return address), RV (return value) e FP
(frame pointer).\\
In particolare, HP serve per puntare alla prossima locazione disponibile dello
heap; assumendo di usare gli indirizzi bassi per lo heap, HP contiene inizialmente
il valore 0.\\

\begin{itemize}
  \item Implementare tutte le operazioni per le nuove espressioni
  \item Implementare il dynamic dispatch $==>$ implementare e definire layout oggetti e classi
  \item La generazione di codice oggetto è fatta utilizzando una grammatica con attributi,
vedere SVM.g4).
Definire una grammatica SENZA attributi (come FOOL.g4) e definire una visita
dell'albero sintattico per generare il codice.
\end{itemize}

\subsubsection{Opzionali}

La deallocazione degli oggetti nello heap (garbage collection) non è obbligatoria.

\section{Struttura del progetto}

Il codice sorgente del progetto è contenuto nella sottodirectory source/ che è così divisa:

\begin{itemize}
  \item \textbf{ast/} contiene i nodi dell'albero di sintassi astratta generati dal parser
  \begin{itemize}
    \item \textbf{ast/types/}
    in particolare, contiene quei nodi che rappresentano dei tipi all'interno della grammatica
  \end{itemize}
  \item \textbf{grammars/}
    contiene i file .g4 per le grammatiche FOOL e SVM con i rispettivi parser e le implementazioni dei visitor per la visita dell'ast e del bytecode
  \item \textbf{lib/}
    contiene i jar delle libreria di ANTLRv4, di commons-cli per eseguire il progetto da riga di comando
    e la libreria YAML di supporto al testing
  \item \textbf{testMain/}
    contiene le classi principali per l'esecuzione del progetto, ovvero le
    due configurazioni di run, Main.java per l'esecuzione standard
    e TestSuite.java per l'esecuzione dei test contenuti nel file testSuite.yml in formato YAML e il CommandLineMain
    per l'esecuzione da riga di comando.
  \item \textbf{utils/}
    contiene le classi di supporto per la symbol table, il type checking e altre funzioni ausiliarie.
    % TODO scrivere di più in questo ultimo punto?

\end{itemize}

Il progetto è stato sviluppato usando IntelliJ IDEA, si consulti il file README.md per le istruzioni
su come aprire ed eseguire il progetto con il suddetto IDE oppure utilizzando Eclipse o il terminale.

\section{Caratteristiche del linguaggio e grammatica}

Un tipico programma scritto in linguaggio FOOL è formato da un insieme di blocchi: ogni blocco può essere una dichiarazione di classe (al top level)
oppure una sequenza di dichiarazioni introdotte dalla keyword \textit{let}, seguite da un'altra sequenza di statement in cui le variabili dichiarate vengono usate, introdotta
dalla keyword \textit{in}.\\


\begin{lstlisting}
class A (int x = 1, int y = 2) {
  void m() print(0);
}
\end{lstlisting}

Le espressioni sono state estese a comprendere gli operatori $<=, >=, ||, \&\&, /, - $
   e not nella seguente maniera:\\

\begin{lstlisting}
exp   : left=operand (operator=(EQ | LEQ | GEQ ) right=exp)? ;

operand:  left=term (operator=(PLUS | MINUS) right=operand)? ;

term  : left=factor (operator=(TIMES | DIV) right=term)? ;

factor : left=atom (operator=( OR | AND) right=factor)? ;

atom : (NOT)? (MINUS)? val=value ;

value  :
        INTEGER                            #intVal
      | BOOLVAL                            #boolVal
      | NULL                               #nullVal
      | LPAR exp RPAR                      #baseExp
      | IF LPAR cond=exp RPAR THEN CLPAR thenBranch=exp CRPAR ELSE CLPAR elseBranch=exp CRPAR  #ifExp
      | var     #varExp
      | ID (LPAR (exp (COMMA exp)* )? RPAR )         #funExp
      | object=var DOT memberName=ID ( LPAR (exp (COMMA exp)* )? RPAR )?  #methodExp
      | NEW className=ID (LPAR RPAR)       #newExp
      ;

\end{lstlisting}

Sono stati aggiunti gli statement\\

\begin{lstlisting}
stm : (var | object=var DOT fieldName=ID) ASM exp #varStmAssignment
  | IF cond=exp THEN CLPAR thenBranch=stms CRPAR (ELSE CLPAR elseBranch=stms CRPAR)?  #ifStm
  | object=var DOT memberName=ID ( LPAR (exp (COMMA exp)* )? RPAR )?  #methodStm
  | PRINT LPAR exp (COMMA exp)* RPAR  #printStm
  | ID (LPAR (exp (COMMA exp)* )? RPAR )         #funStm
  ;

stms : ( stm )+  ;

\end{lstlisting}

uno statement può essere un assegnamento (semplice o a campo di un oggetto), un condizionale, una print
o una chiamata di funzione/metodo.\\
\newpage
Una dichiarazione di classe viene fatta nel modo seguente:\\

\begin{lstlisting}
class hero {
    bool iAmBatman() return true;
};

class super extends hero(int x = 0, bool cond = true) {
    int fun() return 1;
    int soMuchFun(int a, bool b) return 1000;
};
\end{lstlisting}

dove le parentesi tonde delimitano i campi e le parentesi graffe i metodi. Una classe può contenere nessun campo
ma deve contenere sempre almeno un metodo. Una classe puo` estenderne un'altra (di cui diventera' una sottoclasse)
ereditandone campi e metodi, utilizzando la keyword \textit{extends}.\\

\begin{lstlisting}
classdec : CLASS className=ID ( EXTENDS superName=ID )? (LPAR varasm (COMMA varasm)* RPAR)? CLPAR (fundec SEMIC)+ CRPAR ;

\end{lstlisting}

% TODO caratteristica da cambiare?
Un oggetto può essere istanziato utilizzando la keyword \textit{new}. Il costruttore deve essere richiamato senza argomenti, mentre i valori dei campi
sono stati già inizializzati durante la dichiarazione della classe e potranno essere modificati successivamente
tramite assegnamento.\\

%TODO completare...
Ulteriori caratteristiche del linguaggio sono le seguenti:\\
\begin{itemize}
  \item Tutte le variabili devono essere inizializzate al momento della dichiarazione (così come vale
 per i campi di una classe).
  \item Una variabile può avere tipo intero, booleano o classe (se è un oggetto).
  \item Una funzione può avere tipo di ritorno void
  \item È stato inserito il tipo null che è sottotipo di classe, per consentirne l'assegnamento ad un oggetto.
  \item Una funzione può opzionalmente avere un blocco \textit{let in} all'interno del suo body, che è formato da
  statement oppure statement ed eventualmente un'espressione preceduta dalla keyword \textit{return} nel caso in
  cui il suo tipo di ritorno sia diverso da void.
  %TODO completare...
\end{itemize}

\section{Analisi lessicale e sintattica (AST)}
L'interfaccia Node, implementata da tutti i nodi dell'ast è stata modificata nel seguente modo:\\
\begin{itemize}
  \item il metodo \textbf{checkSemantics()} ha come tipo di ritorno HashSet$<$String$>$ invece di ArrayList$<$Semantic Error$>$;
  l'oggetto di tipo String rappresenta la stringa che contiene l'errore semantico e si è
  optato per una gestione degli errori con HashSet per facilitare il controllo sull'inserimento
  di duplicati.
  \item il metodo \textbf{typeCheck()} adesso solleva un'eccezione quando viene rilevato un errore di tipo
  (vedi file source/utils/TypeCheckException.java).
  \item è stato aggiunto il metodo \textbf{getID()} che restituisce l'identificatore di un oggetto sotto forma di stringa.
\end{itemize}


%\subsection{Nodi degli operatori}
%La grammatica iniziale è stata estesa a comprendere gli operatori:

%\begin{itemize}
%  \item relazionali ($==, <=, >=$)
%  \item aritmetici ($+,-,*,/,-$ unario)
%  \item logici (and, or, not)
%\end{itemize}

\subsection{Nodi delle funzioni}
\begin{itemize}
  \item \textbf{FunDecNode} rappresenta la dichiarazione di una funzione, in esso sono memorizzati
  il nome della funzione, il suo tipo di ritorno, la lista dei parametri, la lista delle dichiarazioni e il corpo della funzione.\\
  Inoltre il nodo memorizza l'entry della symbol table associata alla funzione stessa.
  \item \textbf{FunExpNode} rappresenta la chiamata di una funzione, in esso sono memorizzati l'id della funzione,
  gli argomenti, il nesting level e una variabile di supporto classID per gestire la chiamata di metodo che avviene senza dot notation.
  Inoltre il nodo memorizza l'entry della symbol table associata alla funzione stessa.


\end{itemize}

\subsection{Nodi per la gestione delle classi}
\begin{itemize}
  \item \textbf{BlockClassDecNode} rappresenta la dichiarazione di una classe, e contiene oltre ai metodi implementati dell'
  interfaccia Node, le utility getMethods() e getFields()
  \item \textbf{ClassMethodNode} rappresenta la chiamata di metodo (o.m()), è sottoclasse di FunExpNode
  \item \textbf{ClassFieldNode} rappresenta il campo di una classe
  \item \textbf{MethodDecNode} rappresenta la dichiarazione di metodo
  \item \textbf{ClassType} rappresenta il tipo classe, memorizza l'id, l'id dell'eventuale superclasse, la lista dei campi e dei metodi.
  Contiene getter e setter per gestire questi campi.
\end{itemize}
\section{Analisi semantica}
\subsection{Symbol table}

La costruzione della symbol table avviene visitando l'ast e richiamando su un ogni nodo il metodo \textbf{checkSemantics()},
che a partire dal primo nodo ProgNode (che rappresenta la start rule della grammatica) viene richiamata due volte.
Le due visite successive servono per la gestione delle dichiarazioni di classi e di funzioni/metodi.
Nel caso delle dichiarazioni di classi, la prima passata viene utilizzata per raccogliere tutte le dichiarazioni, mentre la seconda
serve per gestire campi, metodi, oggetti e risolvere le relazioni di sottotipaggio tra classi.
Nel caso di funzioni/metodi, la doppia visita consente di implementare il meccanismo di mutua ricorsione, ovvero consente
che nel corpo di una funzione possa essere chiamata un'altra funzione non ancora definita. Lo stesso vale per i metodi.

La tabella dei simboli viene gestita utilizzando la classe Environment (contenuta nella sottodirectory utils)
e i metodi di supporto che contiene.\\
La classe contiene i seguenti campi:\\

\begin{lstlisting}
private ArrayList<HashMap<String, SymbolTableEntry>> symTable;
private int nestingLevel;
private int offset;
private boolean secondCheck; // questa e la successiva gestiscono le passate della checkSemantic
private boolean secondFunCheck;
private String definingClass = null; // indica il nome della classe da cui stiamo aggiornando la st
\end{lstlisting}

In più contiene (oltre a getter e setter per i campi) anche i metodi:\\
% TODO scrivere come vengono dati questi id...
\begin{itemize}
  \item \textbf{public int decreaseOffset()}
  \item \textbf{public int increaseOffset()}
  \item \textbf{public SymbolTableEntry getActiveDec(String id)} scorre la symbol table
  alla ricerca della entry corrispondente alla dichiarazione al momento attiva nell'ambiente per l'oggetto rappresentato da id.
  \item \textbf{public void pushScope()} aggiunge una nuova tabella hash alla lista che rappresenta la symbol table, con nesting level incrementato.
  \item \textbf{public void popScope()} rimuove dalla symbol table la hash corrispondente al nesting level corrente, e poi lo decrementa.
  \item \textbf{public SymbolTableEntry getClassEntry(String classID)} cerca nella symbol table la entry della classe rappresentata da classID
  %\item \textbf{public void updateClassEntry(ClassType type)} % la usiamo per aggiornare il tipo dinamico? non la stiamo usando

\end{itemize}

La tabella dei simboli viene riempita utilizzando la classe SymbolTableEntry che possiede i seguenti campi:
\begin{lstlisting}
private int nestingLevel;
private int offset;
private Node type;  // nel caso degli oggetti, indica il tipo dinamico
private String className; // usata nel caso di entry che rappresentano classi
private Node staticType; // usata nel caso di classi
\end{lstlisting}

\subsection{Type check}
I tipi su cui si basa il sistema di tipaggio di FOOL sono i seguenti:

\begin{itemize}
  \item BoolType
  \item ClassType
  \item FunType
  \item IntType
  \item NullType
  \item VoidType
\end{itemize}

Il sottotipaggio viene controllato utilizzando la funzione
\begin{itemize}
\item public static boolean subtypeOf(Node a, Node b)
\end{itemize}
che restituisce \textit{true} se il nodo a è sottotipo del nodo b (in Helpers).
In particolare, bool è sottotipo di int, void è sottotipo di classe, mentre una classe è sottoclasse di un'altra se
intersecando la lista delle superclassi della prima con la lista delle superclassi della seconda si ottiene un insieme non vuoto.\\
Il sottotipaggio tra funzioni/metodi viene gestito all'interno delle typeCheck() di FunDecNode e MethodDecNode, come da specifica, il controllo viene eseguito
su tipo di ritorno e tipi e numero dei parametri per verificare che i tipi delle funzioni siano compatibili.\\
\newline
Si sono implementate le regole di tipaggio per tutti i costrutti:
% riporto solo quelle effettivamente necessarie a fare type inference ( i costrutti che danno void non contribuiscono al tipo dell'albero)

\begin{itemize}
  \item costanti intere
  $$ \frac{\text{x \ \ is \ \ an} \ \ int \ \ \text{token}}{\vdash x : int}[IntVal] $$
  \item costanti booleane
  $$ \frac{}{\vdash true : bool}[BoolVal_1] \qquad \frac{}{\vdash false : bool}[BoolVal_2] $$
  \item operatori logici e relazionali
  % not
  $$ \frac{\Gamma\vdash e : bool}{\vdash ! e : bool}[Not] $$
  % and, or
  $$ \frac{\Gamma \vdash e_1 : bool \qquad \Gamma \vdash e_2 : bool}{\Gamma \vdash e_1 \ && \ e_2 : bool}[And] \qquad \frac{\Gamma \vdash e_1 : bool \qquad \Gamma \vdash e_2 : bool}{\Gamma \vdash e_1 \ || \ e_2 : bool}[Or] $$
  % equal
  $$ \frac{\Gamma \vdash e_1 : T_1 \qquad \Gamma \vdash e_2 : T_2 \qquad T_1 <: T \qquad T_2<:T}{\Gamma \vdash e_1 \ == \ e_2 : bool}[Equal] $$
  % lessequal, greaterequal
  $$ \frac{\Gamma \vdash e_1 : int \qquad \Gamma \vdash e_2 : int}{\Gamma \vdash e_1 \ <= \ e_2 : bool}[LessEqual] \qquad \frac{\Gamma \vdash e_1 : int \qquad \Gamma \vdash e_2 : int}{\Gamma \vdash e_1 \ >= \ e_2 : bool}[GreaterEqual] $$

  \item operatori aritmetici
  % plus, sub
  $$ \frac{\Gamma \vdash e_1 : int \qquad \Gamma \vdash e_2 : int}{\Gamma \vdash e_1 \ + \ e_2 : int}[Plus] \qquad \frac{\Gamma \vdash e_1 : int \qquad \Gamma \vdash e_2 : int}{\Gamma \vdash e_1 \ - \ e_2 : int}[Sub] $$
  % times, div
  $$ \frac{\Gamma \vdash e_1 : int \qquad \Gamma \vdash e_2 : int}{\Gamma \vdash e_1 \ + \ e_2 : int}[Times] \qquad \frac{\Gamma \vdash e_1 : int \qquad \Gamma \vdash e_2 : int}{\Gamma \vdash e_1 \ - \ e_2 : int}[Div] $$
  % unary minus
  $$ \frac{\Gamma \vdash e_1 : int}{\Gamma \vdash (- e_1) : int}[UnaryMinus] $$
  \item condizionale
  % ifexp1
  $$ \frac{\Gamma \vdash c : bool \qquad \Gamma \vdash e_1 : T_1 \qquad \Gamma \vdash e_2 : T_2 \qquad T_2 <: T_1}{\Gamma \vdash if \ \ (c) \ \ then \ \ {e_1} \ \ else \ \ {e_2} : T1}[IfExp_1] $$
  % ifexp2
  $$ \frac{\Gamma \vdash c : bool \qquad \Gamma \vdash e_1 : T_1 \qquad \Gamma \vdash e_2 : T_2 \qquad T_1 <: T_2}{\Gamma \vdash if \ \ (c) \ \ then \ \ {e_1} \ \ else \ \ {e_2} : T2}[IfExp_2] $$
  % ifstm
  $$ \frac{\Gamma \vdash c : bool \qquad \Gamma \vdash s_1 : T_1 \qquad \Gamma \vdash s_2 : T_2 \qquad T_1 <: void \qquad T_2 <: void}{\Gamma \vdash if \ \ (c) \ \ then \ \ {s_1} \ \ else \ \ {s_2} : void}[IfStm] $$

  \item variabili %TODO check
  $$ \frac{}{\Gamma [x \rightarrow T] \vdash x : T}[Var] $$

  \item print % TODO check
  $$ \frac{\Gamma \vdash e_1 : T_1, ..., e_n : T_n \qquad T_1,...,T_n != void}{\Gamma \vdash print(e_1,...,e_n) : void }[Print]$$

  \item chiamata di funzione (con subtyping)
  $$ \frac{\Gamma \vdash f : (T_1, ..., T_n) \rightarrow T \qquad (\Gamma \vdash e_1 : <: T_1' \ \ldots \ e_n : T_n' \ \ \ T_i' <: T_i )\textsuperscript{i \in 1,...n}}{\Gamma \vdash f(e_1,...,e_n) : T}[SbtFunCall] $$

  \item chiamata di metodo (con subtyping)
  $$ \frac{\Gamma(o) = C \qquad \Gamma(c)(m) = T_1, ... , T_n \rightarrow T \qquad (\Gamma \vdash e_i : T_i' \ \ \ T_i' <: T_i)\textsuperscript{i \in 1..n}}{\Gamma \vdash o.m(e_1,...,e_n) : T}[SbtMethodCall] $$

  \item accesso ad un campo
  $$ \frac{\Gamma \vdash o : C \qquad C \vdash x : T}{\Gamma \vdash o.x : T}[Field] $$

  \item istanziazione di un oggetto (new) % TODO check

  $$ \frac{\Gamma \vdash new \ C : () \rightarrow C}{\Gamma \vdash new \ C() : C}[New] $$

  \item assegnamento % è uno statement
  $$ \frac{\Gamma(x) = T_1 \qquad \Gamma \vdash e : T_2 \qquad T_2 <: T_1}{\Gamma \vdash x = e : void}[Assignment] $$

  \item comandi
  $$ \frac{\Gamma \vdash stm : void \qquad \Gamma \vdash stms : void}{\Gamma \vdash stm ; stms : void}[SeqStms] $$
\end{itemize}
\section{Generazione del codice}

\subsection{Gestione degli offset, stack, heap}
\subsection{Layout di un oggetto}
\subsection{Grammatica SVM senza attributi e SVMVisitor}
\subsection{Dynamic dispatch}

\section{Conclusioni}

%\begin{thebibliography}{9}
  % type bibliography here
%\end{thebibliography}

\end{document}
